pipeline {
  agent { label 'docker' }

  options {
    timestamps()
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '20'))
  }

  parameters {
    choice(name: 'DEPLOY_STRATEGY', choices: ['rolling', 'canary', 'blue-green'], description: 'Kubernetes deploy strategy')
    string(name: 'NAMESPACE', defaultValue: 'skillify', description: 'K8s namespace')
    booleanParam(name: 'RUN_TESTS', defaultValue: true, description: 'Run unit tests')
    booleanParam(name: 'PUSH_LATEST', defaultValue: true, description: 'Also push :latest tag')
    string(name: 'BRANCH', defaultValue: 'main', description: 'Branch to build')
  }

  environment {
    DOCKERHUB_CREDENTIALS = 'docker-hub-creds' // Jenkins credentials id
    KUBECONFIG_CREDENTIALS = 'kubeconfig'      // Jenkins file credential id for kubeconfig
    DOCKER_USER = 'nigachu42'
  }

  stages {
    stage('Checkout') {
      steps {
        checkout([$class: 'GitSCM', branches: [[name: "*/${params.BRANCH}"]], userRemoteConfigs: scm.userRemoteConfigs])
        script {
          COMMIT = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
        }
      }
    }

    stage('Install & Test') {
      parallel {
        stage('Frontend Build') {
          steps {
            dir('client') {
              sh 'npm ci'
              sh 'npm run build'
            }
          }
        }
        stage('Backend & Services Test') {
          steps {
            script {
              def backends = ['server']
              backends.each { path ->
                dir(path) {
                  sh 'npm ci'
                  sh params.RUN_TESTS ? 'npm test || true' : 'echo "Skipping tests"'
                }
              }
            }
          }
        }
      }
    }

    stage('Docker Build') {
      steps {
        script {
          def images = [
            [name: 'frontend', context: 'client', dockerfile: 'services/frontend/Dockerfile'],
            [name: 'backend',  context: 'server', dockerfile: 'services/backend/Dockerfile']
          ]
          images.each { img ->
            echo "Building ${img.name} from ${img.context} using ${img.dockerfile}"
            sh "docker build -t ${DOCKER_USER}/${img.name}:${COMMIT} -f ${img.dockerfile} ${img.context}"
          }
        }
      }
    }

    stage('Docker Push') {
      steps {
        withCredentials([usernamePassword(credentialsId: env.DOCKERHUB_CREDENTIALS, usernameVariable: 'DOCKER_USER_SECRET', passwordVariable: 'DOCKER_PASS_SECRET')]) {
          sh 'echo $DOCKER_PASS_SECRET | docker login -u $DOCKER_USER_SECRET --password-stdin'
          script {
            def services = ['frontend','backend']
            services.each { svc ->
              if (params.PUSH_LATEST) {
                sh "docker tag ${DOCKER_USER}/${svc}:${COMMIT} ${DOCKER_USER}/${svc}:latest"
              }
              sh "docker push ${DOCKER_USER}/${svc}:${COMMIT}"
              if (params.PUSH_LATEST) {
                sh "docker push ${DOCKER_USER}/${svc}:latest"
              }
            }
          }
        }
      }
    }

    stage('Deploy to Kubernetes') {
      steps {
        withCredentials([file(credentialsId: env.KUBECONFIG_CREDENTIALS, variable: 'KUBECONFIG_FILE')]) {
          sh '''
            mkdir -p $HOME/.kube
            cp $KUBECONFIG_FILE $HOME/.kube/config
          '''
          script {
            def services = ['backend','frontend']
            if (params.DEPLOY_STRATEGY == 'rolling') {
              services.each { svc ->
                sh "kubectl -n ${params.NAMESPACE} set image deployment/${svc} ${svc}=${DOCKER_USER}/${svc}:${COMMIT} --record || true"
              }
            } else if (params.DEPLOY_STRATEGY == 'canary') {
              sh "bash services/ci/canary_rollout.sh ${params.NAMESPACE} ${COMMIT} ${DOCKER_USER}"
            } else if (params.DEPLOY_STRATEGY == 'blue-green') {
              sh "bash services/ci/blue_green_deploy.sh ${params.NAMESPACE} ${COMMIT} ${DOCKER_USER}"
            }
          }
        }
      }
    }

    stage('Post-Deploy Health Check') {
      steps {
        sh 'bash services/ci/health_check.sh || true'
      }
    }
  }

  post {
    success {
      echo "SUCCESS: ${COMMIT}"
    }
    failure {
      echo "FAILED: see logs"
      script {
        // Attempt automated rollback on failure for rolling/canary
        if (params.DEPLOY_STRATEGY in ['rolling','canary']) {
          sh 'bash services/ci/rollback.sh ${NAMESPACE} || true'
        }
      }
    }
  }
}
